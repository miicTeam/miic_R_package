---
title: "Consensus skeleton feature"
author: "Marcel Ribeiro-Dantas (marcel.ribeiro-dantas@curie.fr)"
date: "7/25/2019"

output:
  html_document:
    toc: true # table of content true
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    toc_float: true
    number_sections: false  ## if you want number sections at each table header
    theme: flatly  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Robustness analysis
The goal of this feature is to evaluate the effect of small variations in the sample used as input to the MIIC algorithm, so that we can measure its robustness to such events.

# Proposed solution
One way to do such analysis is by resampling the original sample $N$ (nSkeletons) times and inferring a skeleton for each of these resamples. Then, the idea is to create a _consensus skeleton_ based on all the inferred skeletons and compare it to the final network, inferred with the original sample. The _consensus skeleton_ is made of all edges that were present in at least $N\%$ (doConsensus) of the skeletons inferred from the resamplings

# Resampling methods
There are several resampling methods, as one can see in the figure below. For now, there are two methods implemented in MIIC: [Bootstraping](#bootstraping) and [jackknife](#jackknife).

```{r resampling_methods, echo=FALSE, fig.cap="Resampling with different methods. Taken from an [StackOverflow answer](https://stats.stackexchange.com/questions/104040/resampling-simulation-methods-monte-carlo-bootstrapping-jackknifing-cross).", out.width = '100%'}
knitr::include_graphics("figs/resampling methods.jpg")
```

## Bootstraping {#bootstraping}
Bootstraping generally refers to any resampling method that does resamples with replacement. This implies that some samples may not occur at all in the resample, while others may occurr more than once. The boostrap method for the consensus skeleton in MIIC works by taking $N$ (nSkeletons) resamplings with replacement.

## Jackknife {#jackknife}
Jackknife is a resampling method, without replacement, that does undersampling. One example would be to randomly choose 8 out of 10 samples, meaning a fraction of 80%. 

# Examples
In our example, let's use the _hematoData_ data package contained in the MIIC R package and build the consensus skeleton through 10 and 100 skeletons inferred from resamples.

## N=10
```{r}
library(miic)
data(hematoData)
nske = 10
```

### By bootstrapping
The consensus skeleton will be made of edges that are present in $80\%$ of the skeletons.
```{r eval=FALSE}
set.seed(2019)
miic.res = miic(inputData = hematoData, latent = TRUE, confidenceShuffle = 10,
                confidenceThreshold = 0.001,
                doConsensus = 80,
                nSkeletons = nske)
```

*Results*

```{r echo=TRUE, message=FALSE, eval=FALSE}
library(ggplot2)
library(dplyr)
as_tibble(miic.res$skeletons) %>%
  group_by(x, y) %>%
  summarise(count = n(), I = mean(as.numeric(I))) %>%
  ggplot(aes(x=count*100/nske, y=I)) + geom_point() + geom_jitter(height = 5) +
  geom_smooth() +
  labs(title="Edges in skeletons inferred from resamplings",
       x = "How often this edge was inferred in the skeletons",
       y = "Average Conditional Mutual Information for this edge")
```

```{r bs_fig1_10, echo=FALSE, out.width = '100%'}
knitr::include_graphics("figs/bootstrap_1_n10.png")
```

```{r echo=TRUE, message=FALSE, eval=FALSE}
library(ggplot2)
library(dplyr)
as_tibble(miic.res$skeletons) %>%
  group_by(x, y) %>%
  summarise(count = n(),
            ai_vect = mean(as.numeric(ai_vect_n)),
            I = mean(as.numeric(I))) %>%
  ggplot(aes(x=count*100/nske, y=ai_vect, color = log(I))) + geom_jitter(height = 0.01) + geom_point() +
  geom_smooth() +
  labs(title="Edges in skeletons inferred from resamplings",
       x = "How often this edge was inferred in the skeletons",
       y = "Number of nodes in the d-separation set",
       fill = "Log of average conditional mutual information")
``` 

```{r bs_fig2_10, echo=FALSE, out.width = '100%'}
knitr::include_graphics("figs/bootstrap_2_n100.png")
```

```{r eval=FALSE}
# Comparing final network to consensus skeleton
final_network <- as.data.frame(cbind(miic.res$retained.edges.summary$x,
                                     miic.res$retained.edges.summary$y))
colnames(final_network) <- colnames(miic.res$consensus_table) <- c('x', 'y')

# Proportion of final network which is not in the consensus table
n_edges_not_in_consensus <- nrow(dplyr::setdiff(final_network,
                                                miic.res$consensus_table))
n_total_final_network <- nrow(final_network)
prop_edges_not_in_consensus <- n_edges_not_in_consensus*100/n_total_final_network
prop_edges_in_consensus <- 100-prop_edges_not_in_consensus
paste0(prop_edges_in_consensus, '% of similarity')
```

[1] "65.3333333333333% of similarity"

### By jackknife
The consensus skeleton will be made of edges that are present in $80\%$ of the skeletons, and the resampling will be done randomly from $90\%$
of the original sample.
```{r eval=FALSE}
set.seed(2019)
miic.res = miic(inputData = hematoData, latent = TRUE, confidenceShuffle = 10,
                confidenceThreshold = 0.001,
                doConsensus = 80,
                nSkeletons = nske,
                proportionToUndersample = 90)
```

*Results*

```{r echo=TRUE, message=FALSE, eval=FALSE}
library(ggplot2)
library(dplyr)
as_tibble(miic.res$skeletons) %>%
  group_by(x, y) %>%
  summarise(count = n(), I = mean(as.numeric(I))) %>%
  ggplot(aes(x=count*100/nske, y=I)) + geom_point() + geom_jitter(height = 5) +
  geom_smooth() +
  labs(title="Edges in skeletons inferred from resamplings",
       x = "How often this edge was inferred in the skeletons",
       y = "Average Conditional Mutual Information for this edge")
```

```{r jk_fig1_10, echo=FALSE, out.width = '100%'}
knitr::include_graphics("figs/jackknife_1_n100.png")

```

```{r echo=TRUE, message=FALSE, eval=FALSE}
library(ggplot2)
library(dplyr)
as_tibble(miic.res$skeletons) %>%
  group_by(x, y) %>%
  summarise(count = n(),
            ai_vect = mean(as.numeric(ai_vect_n)),
            I = mean(as.numeric(I))) %>%
  ggplot(aes(x=count*100/nske, y=ai_vect, color = log(I))) + geom_jitter(height = 0.01) + geom_point() +
  geom_smooth() +
  labs(title="Edges in skeletons inferred from resamplings",
       x = "How often this edge was inferred in the skeletons",
       y = "Number of nodes in the d-separation set",
       fill = "Log of average conditional mutual information")
``` 

```{r jk_fig2_10, echo=FALSE, out.width = '100%'}
knitr::include_graphics("figs/jackknife_2_n100.png")
```

```{r eval=FALSE}
# Comparing final network to consensus skeleton
final_network <- as.data.frame(cbind(miic.res$retained.edges.summary$x,
                                     miic.res$retained.edges.summary$y))
colnames(final_network) <- colnames(miic.res$consensus_table) <- c('x', 'y')

# Proportion of final network which is not in the consensus table
n_edges_not_in_consensus <- nrow(dplyr::setdiff(final_network,
                                                miic.res$consensus_table))
n_total_final_network <- nrow(final_network)
prop_edges_not_in_consensus <- n_edges_not_in_consensus*100/n_total_final_network
prop_edges_in_consensus <- 100-prop_edges_not_in_consensus
paste0(prop_edges_in_consensus, '% of similarity')
```

[1] "86.6666666666667% of similarity"

## N=100
```{r}
library(miic)
data(hematoData)
nske = 100
```

### By bootstrapping
The consensus skeleton will be made of edges that are present in $80\%$ of the skeletons.
```{r eval=FALSE}
set.seed(2019)
miic.res = miic(inputData = hematoData, latent = TRUE, confidenceShuffle = 10,
                confidenceThreshold = 0.001,
                doConsensus = 80,
                nSkeletons = nske)
```

*Results*

```{r echo=TRUE, message=FALSE, eval=FALSE}
library(ggplot2)
library(dplyr)
as_tibble(miic.res$skeletons) %>%
  group_by(x, y) %>%
  summarise(count = n(), I = mean(as.numeric(I))) %>%
  ggplot(aes(x=count*100/nske, y=I)) + geom_point() + geom_jitter(height = 5) +
  geom_smooth() +
  labs(title="Edges in skeletons inferred from resamplings",
       x = "How often this edge was inferred in the skeletons",
       y = "Average Conditional Mutual Information for this edge")
```

```{r bs_fig1_100, echo=FALSE, out.width = '100%'}
knitr::include_graphics("figs/bootstrap_1_n100.png")
```

```{r echo=TRUE, message=FALSE, eval=FALSE}
library(ggplot2)
library(dplyr)
as_tibble(miic.res$skeletons) %>%
  group_by(x, y) %>%
  summarise(count = n(),
            ai_vect = mean(as.numeric(ai_vect_n)),
            I = mean(as.numeric(I))) %>%
  ggplot(aes(x=count*100/nske, y=ai_vect, color = log(I))) + geom_jitter(height = 0.01) + geom_point() +
  geom_smooth() +
  labs(title="Edges in skeletons inferred from resamplings",
       x = "How often this edge was inferred in the skeletons",
       y = "Number of nodes in the d-separation set",
       fill = "Log of average conditional mutual information")
``` 

```{r bs_fig2_100, echo=FALSE, out.width = '100%'}
knitr::include_graphics("figs/bootstrap_2_n100.png")
```

```{r eval=FALSE}
# Comparing final network to consensus skeleton
final_network <- as.data.frame(cbind(miic.res$retained.edges.summary$x,
                                     miic.res$retained.edges.summary$y))
colnames(final_network) <- colnames(miic.res$consensus_table) <- c('x', 'y')

# Proportion of final network which is not in the consensus table
n_edges_not_in_consensus <- nrow(dplyr::setdiff(final_network,
                                                miic.res$consensus_table))
n_total_final_network <- nrow(final_network)
prop_edges_not_in_consensus <- n_edges_not_in_consensus*100/n_total_final_network
prop_edges_in_consensus <- 100-prop_edges_not_in_consensus
paste0(prop_edges_in_consensus, '% of similarity')
```

[1] "60% of similarity"

### By jackknife
The consensus skeleton will be made of edges that are present in $80\%$ of the skeletons, and the resampling will be done randomly from $90\%$
of the original sample.
```{r eval=FALSE}
set.seed(2019)
miic.res = miic(inputData = hematoData, latent = TRUE, confidenceShuffle = 10,
                confidenceThreshold = 0.001,
                doConsensus = 80,
                nSkeletons = nske,
                proportionToUndersample = 90)
```

*Results*

```{r echo=TRUE, message=FALSE, eval=FALSE}
library(ggplot2)
library(dplyr)
as_tibble(miic.res$skeletons) %>%
  group_by(x, y) %>%
  summarise(count = n(), I = mean(as.numeric(I))) %>%
  ggplot(aes(x=count*100/nske, y=I)) + geom_point() + geom_jitter(height = 5) +
  geom_smooth() +
  labs(title="Edges in skeletons inferred from resamplings",
       x = "How often this edge was inferred in the skeletons",
       y = "Average Conditional Mutual Information for this edge")
```

```{r jk_fig1_100, echo=FALSE, out.width = '100%'}
knitr::include_graphics("figs/jackknife_1_n100.png")
```

```{r echo=TRUE, message=FALSE, eval=FALSE}
library(ggplot2)
library(dplyr)
as_tibble(miic.res$skeletons) %>%
  group_by(x, y) %>%
  summarise(count = n(),
            ai_vect = mean(as.numeric(ai_vect_n)),
            I = mean(as.numeric(I))) %>%
  ggplot(aes(x=count*100/nske, y=ai_vect, color = log(I))) + geom_jitter(height = 0.01) + geom_point() +
  geom_smooth() +
  labs(title="Edges in skeletons inferred from resamplings",
       x = "How often this edge was inferred in the skeletons",
       y = "Number of nodes in the d-separation set",
       fill = "Log of average conditional mutual information")
``` 

```{r jk_fig2_100, echo=FALSE, out.width = '100%'}
knitr::include_graphics("figs/jackknife_2_n100.png")
```

```{r eval=FALSE}
# Comparing final network to consensus skeleton
final_network <- as.data.frame(cbind(miic.res$retained.edges.summary$x,
                                     miic.res$retained.edges.summary$y))
colnames(final_network) <- colnames(miic.res$consensus_table) <- c('x', 'y')

# Proportion of final network which is not in the consensus table
n_edges_not_in_consensus <- nrow(dplyr::setdiff(final_network,
                                                miic.res$consensus_table))
n_total_final_network <- nrow(final_network)
prop_edges_not_in_consensus <- n_edges_not_in_consensus*100/n_total_final_network
prop_edges_in_consensus <- 100-prop_edges_not_in_consensus
paste0(prop_edges_in_consensus, '% of similarity')
```

[1] "82.6666666666667% of similarity"
