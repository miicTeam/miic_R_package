% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tmiic.plot.R
\name{tmiic.export}
\alias{tmiic.export}
\title{Export temporal miic (tmiic) result to different plotting methods}
\usage{
tmiic.export(
  tmiic_res,
  display = "compact",
  show_self_loops = TRUE,
  method = "igraph",
  pcor_palette = NULL
)
}
\arguments{
\item{tmiic_res}{[a tmiic object]
The object returned by the \code{\link{miic}} execution in temporal mode.}

\item{display}{[a string]. Optional, default value "compact".
Possible values are \emph{"raw"}, \emph{"lagged"}, \emph{"compact"},
\emph{"combine"}, \emph{"unique"}, \emph{"drop"}:
\itemize{
\item When \emph{display} = \emph{"raw"}, the export function will
  use the tmiic graph object as it, leading to the return of a lagged
  graph.
\item When \emph{display} = \emph{"lagged"}, the export function will
  repeat the edges over history assuming stationarity and return a lagged
  graph.
\item When \emph{display} = \emph{"compact"}, the default, nodes
  and edges are converted into a flattened version to produce a compact
  view of the temporal network whilst still presenting all the information
  in the export.\cr
  i.e.: X_lag1->Y_lag0, X_lag2<-Y_lag0 become respectively X->Y lag=1,
  X<-Y lag=2.
\item When \emph{display} = \emph{"combine"}, prior to the export,
  a pre-processing will be applied to kept only one edge
  per couple of nodes. The info_shifted will be the highest one
  of the summarized edges whilst the lag and orientation of the
  summarized edge will be an aggregation.\cr
  i.e.: X_lag2->Y_lag0, X_lag0<-Y_lag1 will become X<->Y lag=1-2 with
  the info_shifted of X_lag2->Y_lag0 if info_shifted of
  X_lag2->Y_lag0 > X_lag0<-Y_lag1.
\item When \emph{display} = \emph{"unique"}, prior to the export,
  a pre-processing will be applied to kept only the edges having the
  highest info_shifted for a couple of nodes.
  If several edges between the sames nodes have the same
  info_shifted, then the edge kept is the one with the minimum lag.\cr
  i.e.: X_lag1->Y_lag0, X_lag0<-Y_lag2 with info_shifted of
  X_lag1->Y_lag0 > X_lag0<-Y_lag2 become X->Y lag=1.
\item When \emph{display} = \emph{"drop"}, prior to the export,
  a pre-processing will be applied to kept only the edges having the
  highest info_shifted for a couple of nodes.
  If several edges between the sames nodes have the same
  info_shifted, then the edge kept is the one with the minimum lag.\cr
  i.e. :  X_lag1->Y_lag0, X_lag0<-Y_lag2 with info_shifted of
  X_lag1->Y_lag0 > X_lag0<-Y_lag2 become X->Y.
  The lag information is dropped during the preprocessing and
  will not be exported.
}}

\item{show_self_loops}{[a boolean] Optional, TRUE by default.
When TRUE, the edges like X_lag0-X_lag1 are exported.
When FALSE, only edges having different nodes are exported.}

\item{method}{A string representing the plotting method.
Currently only "igraph" is supported.}

\item{pcor_palette}{Optional. The color palette used to represent the partial
correlations (the color of the edges). See \code{\link{getIgraph}} for details.}
}
\value{
A graph object adapted to the method.
}
\description{
This function creates an object built from the result returned
by \code{\link{miic}} executed in temporal mode that is ready to be fed to
different plotting methods.
}
\examples{
\donttest{
library(miic)
data(covidCases)
# execute MIIC (reconstruct graph in temporal mode)
tmiic_res <- miic(input_data = covidCases, mode = "TS", n_layers = 3, delta_t = 1, movavg = 14)

# Plot default compact temporal network Using igraph
if(require(igraph)) {
g = tmiic.export(tmiic_res, method="igraph")
plot(g) # Default visualisation, calls igraph::plot.igraph()

# Plot raw temporal network Using igraph
g = tmiic.export(tmiic_res, display="raw", method="igraph")
plot(g) # Default visualisation, calls igraph::plot.igraph()

# Plot full temporal network Using igraph
g = tmiic.export(tmiic_res, display="lagged", method="igraph")
plot(g) # Default visualisation, calls igraph::plot.igraph()

# Specifying layout (see ?igraph::layout_)
l <- layout_on_grid(g, width = 5, height = 3, dim = 2)
plot(g, layout=l)

# Override some graphical parameters
plot(g, edge.arrow.size = 0.75)
plot(g, vertex.shape="none", edge.color="gray85", vertex.label.color="gray10")

# For compact graphs, please be aware that the rendering of
# igraph::plot.igraph() is not optimal when the graph contains
# multiple edges between the same nodes.
# So the recommend way to plot a compact graph is to use tmiic plotting:
plot(tmiic_res)
}

}
}
