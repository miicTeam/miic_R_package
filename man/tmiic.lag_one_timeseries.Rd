% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tmiic.wrapper.R
\name{tmiic.lag_one_timeseries}
\alias{tmiic.lag_one_timeseries}
\title{tmiic.lag_one_timeseries}
\usage{
tmiic.lag_one_timeseries(
  df_timeseries,
  list_nodes_lagged,
  tau,
  movavg,
  delta_tau
)
}
\arguments{
\item{list_nodes_lagged}{[a list] 
The list of variables lagged over \emph{tau} / \emph{delta_tau}}

\item{tau}{[an int > 0] A strictly positive int defining the max lag.
Note that if \emph{delta_tau} is also supplied, \emph{tau} must be a
multiple of \emph{delta_tau}.}

\item{movavg}{[an integer] Optional, -1 by default.\cr
When \emph{movavg} is supplied (integer > 1), a moving average 
operation is applied to the time series.}

\item{delta_tau}{[an integer] Optional, 1 by default.\cr
When \emph{delta_tau} is supplied (integer > 1), the samples will be 
construted using 1 timestep every \emph{delta_tau} timesteps starting 
from the last.\cr 
i.e.: on 1000 timesteps with  \emph{tau} = 14 and \emph{delta_tau} = 7, 
the timesteps kept for the samples conversion will be 1000, 993, 986 
for the first sample, the next sample will use 999, 992, 985 and so on.\cr}

\item{data}{[a dataframe] 
A dataframe containing the time series with variables as columns and
timesteps as rows.}
}
\value{
a dataframe with the samples generated form the timeseries
}
\description{
Reorganizes the data of one timeseries using the history to create lagged
samples in a format usable by miic
}
\details{
The function slices the input data according to  \emph{tau} and 
\emph{delta_tau} parameters. Data are expected to be received in a dataframe 
with variables as columns and timesteps as rows. 

Every timestep (until number of timesteps - \emph{tau} * \emph{delta_tau}) 
is converted into a sample in the lagged graph. Exemple with tau=6 and
delta_tau=3:

\tabular{ccccccc}{
Timestep \tab  Node & value  \tab  Node & value  \tab => \tab Sample \tab  Node & value  \tab  Node & value \cr
  t-6    \tab node1_val(t-6) \tab node2_val(t-6) \tab => \tab   i    \tab node1_lag6_val \tab node2_lag6_val\cr
  t-3    \tab node1_val(t-3) \tab node2_val(t-3) \tab => \tab   i    \tab node1_lag3_val \tab node2_lag3_val\cr
   t     \tab  node1_val(t)  \tab  node2_val(t)  \tab => \tab   i    \tab node1_lag0_val \tab node2_lag0_val\cr
  \cr    \tab                \tab                \tab    \tab        \tab                \tab               \cr
  t-7    \tab node1_val(t-7) \tab node2_val(t-7) \tab => \tab   i'   \tab node1_lag6_val \tab node2_lag6_val\cr
  t-4    \tab node1_val(t-4) \tab node2_val(t-4) \tab => \tab   i'   \tab node1_lag3_val \tab node2_lag3_val\cr
  t-1    \tab node1_val(t-1) \tab node2_val(t-1) \tab => \tab   i'   \tab node1_lag0_val \tab node2_lag0_val\cr
  \cr    \tab                \tab                \tab    \tab        \tab                \tab               \cr
  t-8    \tab node1_val(t-8) \tab node2_val(t-8) \tab => \tab   i"   \tab node1_lag6_val \tab node2_lag6_val\cr
  t-5    \tab node1_val(t-5) \tab node2_val(t-5) \tab => \tab   i"   \tab node1_lag3_val \tab node2_lag3_val\cr
  t-2    \tab node1_val(t-2) \tab node2_val(t-2) \tab => \tab   i"   \tab node1_lag0_val \tab node2_lag0_val\cr
  \cr    \tab                \tab                \tab    \tab        \tab                \tab               \cr
  ...    \tab .............. \tab .............. \tab => \tab ...... \tab .............. \tab ............. \cr
}
until number of timesteps - \emph{tau} * \emph{delta_tau} is reached.
}
