% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tmiic.wrapper.R
\name{tmiic.transform_data_for_miic}
\alias{tmiic.transform_data_for_miic}
\title{tmiic.transform_data_for_miic}
\usage{
tmiic.transform_data_for_miic(
  data_tab,
  tau,
  categoryOrder = NULL,
  sub_sample = -1,
  bootstrap = -1
)
}
\arguments{
\item{data_tab}{[a 2D or 3D array] 
An array of the time series for all nodes and samples of dimensions
[n_samples * n_nodes * n_time] for 3D or [n_nodes * n_time] for 2D.
When a 2D array is supplied, the number of samples is assumed to be 1.}

\item{tau}{[an int] An int defining the max lag}

\item{categoryOrder}{[a data frame] Optional, NULL by default. 
A data frame giving information about how to order the various states of 
categorical variables. This data frame will be lagged as the input 
data on \emph{tau} timesteps.}

\item{subsample}{[an int] Optional, default=-1. When -1, no subsampling
is applied. When > 1, keeps one sample every \emph{subsample} samples.}

\item{boostrap}{[an int] Optional, default=-1. When -1, no bootstraping
is done. When > 0, select randomly \emph{boostrap} samples from the
set of samples, a sample can be selected more than once.}
}
\value{
a 2D array of dimensions [ n_samples * (n_time -  \emph{tau}) ), 
                                   n_nodes * ( \emph{tau}+1) ]
}
\description{
Reorganizes the data using the history to create lagged nodes and extra 
samples in a format usable by miic
}
\details{
The function slices the input data according to the lag max argument 
\emph{tau}. Data are expected to be received in a 3 dimensional array 
[n_samples * n_nodes * n_time]. History is assumed to be time ordered from 
the oldest (first rows) to lastest (ending rows).

The number of nodes is increased and renamed on \emph{tau} layers.\cr 
i.e. with \emph{tau}=2: node1, node2 => node1_lag0, node2_lag0, node1_lag1, 
node2_lag1, node1_lag2, node2_lag2.

Every timestep (until number of timesteps - \emph{tau}) is converted into 
a sample in the lagged graph:

_Timestep Node & value   Node & value   => Sample Node & value   Node & value\cr
.. t-2 .. node1_val(t-2) node2_val(t-2) => . i .. node1_lag2_val node2_lag2_val\cr
.. t-1 .. node1_val(t-1) node2_val(t-1) => . i .. node1_lag1_val node2_lag1_val\cr
... t ... node1_val( t ) node2_val( t ) => . i .. node1_lag0_val node2_lag0_val

.. t-3 .. node1_val(t-3) node2_val(t-3) => . i' . node1_lag2_val node2_lag2_val\cr
.. t-2 .. node1_val(t-2) node2_val(t-2) => . i' . node1_lag1_val node2_lag1_val\cr
.. t-1 .. node1_val(t-1) node2_val(t-1) => . i' . node1_lag0_val node2_lag0_val

.. t-4 .. node1_val(t-4) node2_val(t-4) => . i" . node1_lag2_val node2_lag2_val\cr
.. t-3 .. node1_val(t-3) node2_val(t-3) => . i" . node1_lag1_val node2_lag1_val\cr
.. t-2 .. node1_val(t-2) node2_val(t-2) => . i" . node1_lag0_val node2_lag0_val\cr

until number of timesteps - \emph{tau} is reached. The same process is applied
to all input samples.
}
